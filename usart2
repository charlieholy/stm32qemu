#include <stdint.h>

// ========== 寄存器地址定义（替换为 USART2） ==========
#define RCC_APB2ENR    (*(volatile uint32_t*)0x40021018)
#define RCC_APB1ENR    (*(volatile uint32_t*)0x4002101C)  // USART2 挂在 APB1 总线
#define GPIOA_CRL      (*(volatile uint32_t*)0x40010800)
#define GPIOA_ODR      (*(volatile uint32_t*)0x4001080C)
// USART2 寄存器地址
#define USART2_SR      (*(volatile uint32_t*)0x40004400)
#define USART2_DR      (*(volatile uint32_t*)0x40004404)
#define USART2_BRR     (*(volatile uint32_t*)0x40004408)
#define USART2_CR1     (*(volatile uint32_t*)0x4000440C)

// ========== 常量定义 ==========
#define USART_TXE_BIT  (1 << 7)
#define RCC_APB2ENR_AFIOEN (1 << 0)
#define RCC_APB1ENR_USART2EN (1 << 17)  // USART2 时钟使能位

// ========== 函数声明 ==========
static void delay(uint32_t count);
void usart2_init(uint32_t baud);
void usart2_putc(char c);
void usart2_puts(const char* str);

// ========== 延时函数 ==========
static void delay(uint32_t count) {
    while (count--);
}

// ========== USART2 初始化（PA2 TX，无需重映射） ==========
void usart2_init(uint32_t baud) {
    // 1. 使能 GPIOA + AFIO 时钟（APB2）
    RCC_APB2ENR |= (1 << 2) | RCC_APB2ENR_AFIOEN;
    // 2. 使能 USART2 时钟（APB1，注意！USART2 不在 APB2）
    RCC_APB1ENR |= RCC_APB1ENR_USART2EN;

    // 3. 配置 PA2 为复用推挽输出（PA2 对应 CRL 的 8~11 位）
    GPIOA_CRL &= ~(0xF << 8);
    GPIOA_CRL |=  (0xB << 8);  // CNF=10, MODE=11 → 复用推挽

    // 4. 配置波特率（APB1 时钟 36MHz，115200 → BRR=36000000/115200=312.5=0x1388）
    USART2_BRR = 0x1388;

    // 5. 使能 USART2 和发送功能
    USART2_CR1 |= (1 << 13) | (1 << 3);
}

// ========== 发送一个字符 ==========
void usart2_putc(char c) {
    while (!(USART2_SR & USART_TXE_BIT));
    USART2_DR = c;
}

// ========== 发送字符串 ==========
void usart2_puts(const char* str) {
    while (*str) {
        usart2_putc(*str++);
    }
}

// ========== 主函数 ==========
int main(void) {
    uint32_t cnt = 0;

    // 初始化 USART2
    usart2_init(115200);
    usart2_puts("STM32 QEMU USART2 Test\r\n");
    usart2_puts("LED Blink Start...\r\n");

    // 初始化 PA5 为推挽输出（LED）
    RCC_APB2ENR |= (1 << 2);
    GPIOA_CRL &= ~(0xF << 20);
    GPIOA_CRL |=  (0x3 << 20);

    // 主循环
    while (1) {
        GPIOA_ODR ^= (1 << 5);
        delay(1000000);

        usart2_puts("Blink Count: ");
        char buf[4] = {0};
        buf[0] = (cnt / 100) % 10 + '0';
        buf[1] = (cnt / 10) % 10 + '0';
        buf[2] = cnt % 10 + '0';
        usart2_puts(buf);
        usart2_puts("\r\n");
        cnt++;
    }
}

// ========== 复位处理函数 ==========
void Reset_Handler(void) {
    main();
}

// ========== 中断向量表 ==========
__attribute__((section(".isr_vector")))
void (*const g_pfnVectors[])(void) = {
    (void*)0x20005000,
    Reset_Handler
};

//////////////
/opt/stm32/qemu_stm32/output/bin/qemu-system-arm \
-M stm32-p103 \
-kernel stm32f103_led.elf \
-nographic \
-serial telnet:localhost:4444,server,nowait \
-monitor telnet:localhost:5555,server,nowait
///////////////
Makefile
# 运行：在 QEMU 中启动
run: $(TARGET).elf
	$(QEMU) -M stm32-p103 -kernel $< -nographic  -serial telnet:localhost:4444,server,nowait -monitor telnet:localhost:5555,server,nowait

